{
  "version": 3,
  "sources": ["../dta.ts"],
  "sourcesContent": ["import { CellObject, DenseWorkSheet, WorkBook, type utils } from 'xlsx';\nexport { parse, set_utils, version };\n\nconst version = \"0.0.2\";\n\nlet _utils: typeof utils;\n/** Set internal instance of `utils`\n *\n * Usage:\n *\n * ```js\n * const XLSX = require(\"xlsx\");\n * const DTA = require(\"dta\");\n * DTA.set_utils(XLSX.utils);\n * ```\n *\n * @param utils utils object\n */\nfunction set_utils(utils: any): void {\n  _utils = utils;\n}\n\nfunction u8_to_str(u8: Uint8Array): string {\n  return new TextDecoder().decode(u8);\n}\n\n/* sadly the web zealots decided to abandon binary strings */\nfunction u8_to_latin1(u8: Uint8Array): string {\n  return new TextDecoder(\"latin1\").decode(u8);\n}\n\n\n/* TODO: generalize and map to SSF */\nfunction format_number_dta(value: number, format: string, t: number): CellObject {\n  if(value < 0) { const res = format_number_dta(-value, format, t); res.w = \"-\" + res.w; return res; }\n  const o: CellObject = { t: \"n\", v: value };\n  /* NOTE: The Stata CSV exporter appears to ignore the column formats, instead using these defaults */\n  switch(t) {\n    case 251: case 0x62: case 65530: format = \"%8.0g\"; break; // byte\n    case 252: case 0x69: case 65529: format = \"%8.0g\"; break; // int\n    case 253: case 0x6c: case 65528: format = \"%12.0g\"; break; // long\n    case 254: case 0x66: case 65527: format = \"%9.0g\"; break; // float\n    case 255: case 0x64: case 65526: format = \"%10.0g\"; break; // double\n    default: throw t;\n  }\n  try {\n    let w = +((format.match(/%(\\d+)/)||[])[1]) || 8;\n    let k = 0;\n    if(value < 1) ++k;\n    if(value < 0.1) ++k;\n    if(value < 0.01) ++k;\n    if(value < 0.001) ++k;\n    const e = value.toExponential();\n    const exp = e.indexOf(\"e\") == -1 ? 0 : +e.slice(e.indexOf(\"e\")+1);\n    let h = w - 2 - exp;\n    if(h < 0) h = 0;\n    var m = format.match(/%\\d+\\.(\\d+)/);\n    if(m && +m[1]) h = +m[1];\n    o.w = (Math.round(value * 10**(h))/10**(h)).toFixed(h).replace(/^([-]?)0\\./,\"$1.\");\n    o.w = o.w.slice(0, w + k);\n    if(o.w.indexOf(\".\") > -1) o.w = o.w.replace(/0+$/,\"\");\n    o.w = o.w.replace(/\\.$/,\"\");\n    if(o.w == \"\") o.w = \"0\";\n  } catch(e) {}\n  return o;\n}\n\ninterface Payload {\n  /** Offset */\n  ptr: number;\n\n  /** Raw data */\n  raw: Uint8Array;\n\n  /** DataView */\n  dv: DataView;\n}\n\nfunction u8_to_dataview(array: Uint8Array): DataView { return new DataView(array.buffer, array.byteOffset, array.byteLength); }\nfunction valid_inc(p: Payload, n: string): boolean {\n  if(u8_to_str(p.raw.slice(p.ptr, p.ptr + n.length)) != n) return false;\n  p.ptr += n.length;\n  return true;\n}\n\nfunction read_f64(p: Payload, LE: boolean): number | null {\n  p.ptr += 8;\n  const d = p.dv.getFloat64(p.ptr - 8, LE);\n  return d > 8.988e+307 ? null : d;\n}\nfunction read_f32(p: Payload, LE: boolean): number | null {\n  p.ptr += 4;\n  const d = p.dv.getFloat32(p.ptr - 4, LE);\n  return d > 1.701e+38 ? null : d;\n}\nfunction read_u32(p: Payload, LE: boolean) {\n  p.ptr += 4;\n  return p.dv.getUint32(p.ptr - 4, LE);\n}\nfunction read_i32(p: Payload, LE: boolean): number | null {\n  p.ptr += 4;\n  const u = p.dv.getInt32(p.ptr - 4, LE);\n  return u > 0x7fffffe4 ? null : u;\n}\nfunction read_u16(p: Payload, LE: boolean) {\n  p.ptr += 2;\n  return p.dv.getUint16(p.ptr - 2, LE);\n}\nfunction read_i16(p: Payload, LE: boolean): number | null {\n  p.ptr += 2;\n  const u = p.dv.getInt16(p.ptr - 2, LE);\n  return u > 32740 ? null : u;\n}\nfunction read_u8(p: Payload) {\n  return p.raw[p.ptr++];\n}\nfunction read_i8(p: Payload): number | null {\n  let u = p.raw[p.ptr++];\n  u = u < 128 ? u : u - 256;\n  return u > 100 ? null : u;\n}\n\n/* the annotations are from `dtaversion` */\nconst SUPPORTED_VERSIONS_TAGGED = [\n  \"117\", // stata 13\n  \"118\", // stata 14-18\n  \"119\", // stata 15-18 (> 32767 variables)\n  \"120\", // stata 18 (<= 32767, with aliases)\n  \"121\", // stata 18 (> 32767, with aliases)\n];\nconst SUPPORTED_VERSIONS_LEGACY = [\n  102, // stata 1\n  103, // stata 2/3\n  104, // stata 4\n  105, // stata 5\n  108, // stata 6\n  110, // stata 7\n  111, // stata 7\n  112, // stata 8/9\n  113, // stata 8/9\n  114, // stata 10/11\n  115, // stata 12\n];\n\nfunction parse_tagged(raw: Uint8Array): WorkBook {\n  const err = (\"Not a DTA file\");\n\n  const d: Payload = {\n    ptr: 0,\n    raw,\n    dv: u8_to_dataview(raw)\n  };\n\n  let vers: number = 118;\n  let LE: boolean = true;\n  let nvar: number = 0, nobs: number = 0, nobs_lo = 0, nobs_hi = 0;\n  let label: string = \"\", timestamp: string = \"\";\n  const var_types: number[] = [];\n  const var_names: string[] = [];\n  const formats: string[] = [];\n\n  /* 5. Dataset format definition */\n  if(!valid_inc(d, \"<stata_dta>\")) throw err;\n\n  /* 5.1 Header <header> */\n  {\n    if(!valid_inc(d, \"<header>\")) throw err;\n\n    /* <release> */\n    {\n      if(!valid_inc(d, \"<release>\")) throw err;\n      /* NOTE: this assumes the version is 3 characters wide */\n      const res = u8_to_latin1(d.raw.slice(d.ptr, d.ptr+3));\n      d.ptr += 3;\n      if(!valid_inc(d, \"</release>\")) throw err;\n      if(SUPPORTED_VERSIONS_TAGGED.indexOf(res) == -1) throw (`Unsupported DTA ${res} file`);\n      vers = +res;\n    }\n\n    /* <byteorder> */\n    {\n      if(!valid_inc(d, \"<byteorder>\")) throw err;\n      /* NOTE: this assumes the byte order is 3 characters wide */\n      const res = u8_to_latin1(d.raw.slice(d.ptr, d.ptr+3));\n      d.ptr += 3;\n      if(!valid_inc(d, \"</byteorder>\")) throw err;\n      switch(res) {\n        case \"MSF\": LE = false; break;\n        case \"LSF\": LE = true; break;\n        default: throw (`Unsupported byteorder ${res}`);\n      }\n    }\n\n    /* <K> */\n    {\n      if(!valid_inc(d, \"<K>\")) throw err;\n      nvar = (vers === 119 || vers >= 121) ? read_u32(d, LE) : read_u16(d, LE);\n      if(!valid_inc(d, \"</K>\")) throw err;\n    }\n\n    /* <N> */\n    {\n      if(!valid_inc(d, \"<N>\")) throw err;\n      if(vers == 117) nobs = nobs_lo = read_u32(d, LE);\n      else {\n        const lo = read_u32(d, LE), hi = read_u32(d, LE);\n        nobs = LE ? ((nobs_lo = lo) + (nobs_hi = hi) * Math.pow(2,32)) : ((nobs_lo = hi) + (nobs_hi = lo) * Math.pow(2,32));\n      }\n      if(nobs > 1e6) console.error(`More than 1 million observations -- extra rows will be dropped`);\n      if(!valid_inc(d, \"</N>\")) throw err;\n    }\n\n    /* <label> */\n    {\n      if(!valid_inc(d, \"<label>\")) throw err;\n      const w = vers >= 118 ? 2 : 1;\n      const strlen = w == 1 ? read_u8(d) : read_u16(d, LE);\n      if(strlen > 0) label = u8_to_str(d.raw.slice(d.ptr, d.ptr + w));\n      d.ptr += strlen;\n      if(!valid_inc(d, \"</label>\")) throw err;\n    }\n\n    /* <timestamp> */\n    {\n      if(!valid_inc(d, \"<timestamp>\")) throw err;\n      const strlen = read_u8(d);\n      timestamp = u8_to_latin1(d.raw.slice(d.ptr, d.ptr + strlen));\n      d.ptr += strlen;\n      if(!valid_inc(d, \"</timestamp>\")) throw err;\n    }\n\n    if(!valid_inc(d, \"</header>\")) throw err;\n  }\n\n  /* 5.2 Map <map> */\n  {\n    /* TODO: validate map? */\n    if(!valid_inc(d, \"<map>\")) throw err;\n    /* 14 8-byte offsets for:\n      <stata_data>\n      <map>\n      <variable_types>\n      <varnames>\n      <sortlist>\n      <formats>\n      <value_label_names>\n      <variable_labels>\n      <characteristics>\n      <data>\n      <strls>\n      <value_labels>\n      </stata_data>\n      EOF\n    */\n    d.ptr += 8 * 14;\n    if(!valid_inc(d, \"</map>\")) throw err;\n  }\n\n  let stride = 0;\n  /* 5.3 Variable types <variable_types> */\n  {\n    if(!valid_inc(d, \"<variable_types>\")) throw err;\n    for(var i = 0; i < nvar; ++i) {\n      const type = read_u16(d, LE);\n      var_types.push(type);\n      if(type >= 1 && type <= 2045) stride += type;\n      else switch(type) {\n        case 32768: stride += 8; break;\n        case 65525: stride += 0; break; // alias\n        case 65526: stride += 8; break;\n        case 65527: stride += 4; break;\n        case 65528: stride += 4; break;\n        case 65529: stride += 2; break;\n        case 65530: stride += 1; break;\n        default: throw (`Unsupported field type ${type}`);\n      }\n    }\n    if(!valid_inc(d, \"</variable_types>\")) throw err;\n  }\n\n  /* 5.4 Variable names <varnames> */\n  {\n    if(!valid_inc(d, \"<varnames>\")) throw err;\n    const w = vers >= 118 ? 129 : 33;\n    for(let i = 0; i < nvar; ++i) {\n      const name = u8_to_str(d.raw.slice(d.ptr, d.ptr + w));\n      d.ptr += w;\n      var_names.push(name.replace(/\\x00[\\s\\S]*/,\"\"));\n    }\n    if(!valid_inc(d, \"</varnames>\")) throw err;\n  }\n\n  /* 5.5 Sort order of observations <sortlist> */\n  {\n    /* TODO: check sort list? */\n    if(!valid_inc(d, \"<sortlist>\")) throw err;\n    d.ptr += (2 * nvar + 2) * ((vers == 119 || vers == 121) ? 2 : 1);\n    if(!valid_inc(d, \"</sortlist>\")) throw err;\n  }\n\n  /* 5.6 Display formats <formats> */\n  {\n    if(!valid_inc(d, \"<formats>\")) throw err;\n    const w = vers >= 118 ? 57 : 49;\n    for(let i = 0; i < nvar; ++i) {\n      const name = u8_to_str(d.raw.slice(d.ptr, d.ptr + w));\n      d.ptr += w;\n      formats.push(name.replace(/\\x00[\\s\\S]*/,\"\"));\n    }\n    if(!valid_inc(d, \"</formats>\")) throw err;\n  }\n\n  const value_label_names: string[] = [];\n  /* TODO: <value_label_names> */\n  {\n    if(!valid_inc(d, \"<value_label_names>\")) throw err;\n    const w = vers >= 118 ? 129 : 33;\n    for(let i = 0; i < nvar; ++i, d.ptr += w) value_label_names[i] = u8_to_latin1(d.raw.slice(d.ptr, d.ptr + w)).replace(/\\x00.*$/,\"\");\n    if(!valid_inc(d, \"</value_label_names>\")) throw err;\n  }\n\n  /* TODO: <variable_labels> */\n  {\n    if(!valid_inc(d, \"<variable_labels>\")) throw err;\n    const w = vers >= 118 ? 321 : 81;\n    d.ptr += w * nvar;\n    if(!valid_inc(d, \"</variable_labels>\")) throw err;\n  }\n\n  /* 5.9 Characteristics <characteristics> */\n  {\n    if(!valid_inc(d, \"<characteristics>\")) throw err;\n    while(valid_inc(d, \"<ch>\")) {\n      const len = read_u32(d, LE);\n      d.ptr += len;\n      if(!valid_inc(d, \"</ch>\")) throw err;\n    }\n    if(!valid_inc(d, \"</characteristics>\")) throw err;\n  }\n\n  const ws: DenseWorkSheet = (_utils.aoa_to_sheet([var_names], {dense: true} as any) as DenseWorkSheet);\n\n  var ptrs: Array<[number, number, Uint8Array]> = []\n  /* 5.10 Data <data> */\n  {\n    if(!valid_inc(d, \"<data>\")) throw err;\n    for(let R = 0; R < nobs; ++R) {\n      const row: any[] = [];\n      for(let C = 0; C < nvar; ++C) {\n        let t = var_types[C];\n        // TODO: formats, dta_12{0,1} aliases?\n        if(t >= 1 && t <= 2045) {\n          /* NOTE: dta_117 restricts strf to ASCII */\n          let s = u8_to_str(d.raw.slice(d.ptr, d.ptr + t));\n          s = s.replace(/\\x00[\\s\\S]*/,\"\");\n          row[C] = s;\n          d.ptr += t;\n        } else switch(t) {\n          case 65525: d.ptr += 0; break; // alias\n          case 65530: row[C] = read_i8(d); break; // byte\n          case 65529: row[C] = read_i16(d, LE); break; // int\n          case 65528: row[C] = read_i32(d, LE); break; // long\n          case 65527: row[C] = read_f32(d, LE); break; // float\n          case 65526: row[C] = read_f64(d, LE); break; // double\n          case 32768: {\n            row[C] = \"##SheetJStrL##\";\n            ptrs.push([R+1,C, d.raw.slice(d.ptr, d.ptr + 8)]);\n            d.ptr += 8;\n          } break;\n          default: throw (`Unsupported field type ${t} for ${var_names[C]}`);\n        }\n        if(typeof row[C] == \"number\" && formats[C]) row[C] = format_number_dta(row[C], formats[C], t);\n      }\n      _utils.sheet_add_aoa(ws, [row], {origin: -1, sheetStubs: true});\n    }\n    if(!valid_inc(d, \"</data>\")) throw err;\n  }\n\n  /* 5.11 StrLs <strls> */\n  {\n    if(!valid_inc(d, \"<strls>\")) throw err;\n\n    const strl_tbl: string[][] = [];\n      while(d.raw[d.ptr] == 71 /* G */) {\n      if(!valid_inc(d, \"GSO\")) throw err;\n      const v = read_u32(d, LE);\n      let o = 0;\n      if(vers == 117) o = read_u32(d, LE);\n      else {\n        const lo = read_u32(d, LE), hi = read_u32(d, LE);\n        o = LE ? (lo + hi * Math.pow(2,32)) : (hi + lo * Math.pow(2,32));\n        if(o > 1e6) console.error(`More than 1 million observations -- data will be dropped`);\n      }\n      const t = read_u8(d);\n      const len = read_u32(d, LE);\n      if(!strl_tbl[o]) strl_tbl[o] = [];\n      let str = \"\";\n      if(t == 129) {\n        // TODO: dta_117 codepage\n        str = new TextDecoder(vers >= 118 ? \"utf8\" : \"latin1\").decode(d.raw.slice(d.ptr, d.ptr + len));\n        d.ptr += len;\n      } else {\n        str = new TextDecoder(vers >= 118 ? \"utf8\" : \"latin1\").decode(d.raw.slice(d.ptr, d.ptr + len)).replace(/\\x00$/,\"\");\n        d.ptr += len;\n      }\n      strl_tbl[o][v] = str;\n    }\n    if(!valid_inc(d, \"</strls>\")) throw err;\n\n    ptrs.forEach(([R,C,buf]) => {\n      const dv = u8_to_dataview(buf);\n      let v = 0, o = 0;\n      switch(vers) {\n        case 117: { // v(4) o(4)\n          v = dv.getUint32(0, LE);\n          o = dv.getUint32(4, LE);\n        } break;\n\n        case 118: case 120: { // v(2) o(6)\n          v = dv.getUint16(0, LE);\n          const o1 = dv.getUint16(2, LE), o2 = dv.getUint32(4, LE);\n          o = LE ? o1 + o2 * 65536 : o2 + o1 * (2**32);\n        } break;\n\n        case 119: case 121: { // v(3) o(5)\n          const v1 = dv.getUint16(0, LE), v2 = buf[2];\n          v = LE ? v1 + (v2 << 16) : v2 + (v1 << 8);\n          const o1 = buf[3], o2 = dv.getUint32(4, LE);\n          o = LE ? o1 + o2 * 256 : o2 + o1 * (2**32);\n        }\n      }\n      ws[\"!data\"][R][C].v = strl_tbl[o][v];\n    });\n  }\n\n  /* 5.12 Value labels <value_labels> */\n  {\n    const w = vers >= 118 ? 129 : 33;\n    if(!valid_inc(d, \"<value_labels>\")) throw err;\n    while(valid_inc(d, \"<lbl>\")) {\n      let len = read_u32(d, LE);\n      const labname = u8_to_latin1(d.raw.slice(d.ptr, d.ptr + w)).replace(/\\x00.*$/,\"\");\n      d.ptr += w;\n      d.ptr += 3; // padding\n      const labels: string[] = [];\n      {\n        const n = read_u32(d, LE);\n        const txtlen = read_u32(d, LE);\n        const off: number[] = [], val: number[] = [];\n        for(let i = 0; i < n; ++i) off.push(read_u32(d, LE));\n        for(let i = 0; i < n; ++i) val.push(read_u32(d, LE));\n        const str = u8_to_str(d.raw.slice(d.ptr, d.ptr + txtlen));\n        d.ptr += txtlen;\n        for(let i = 0; i < n; ++i) labels[val[i]] = str.slice(off[i], str.indexOf(\"\\x00\", off[i]));\n      }\n      const C = value_label_names.indexOf(labname);\n      if(C == -1) throw new Error(`unexpected value label |${labname}|`);\n      for(let R = 1; R < ws[\"!data\"].length; ++R) {\n        const cell = ws[\"!data\"][R][C];\n        cell.t = \"s\"; cell.v = cell.w = labels[(cell.v as number)||0];\n      }\n      //d.ptr += len; // value_label_table\n      if(!valid_inc(d, \"</lbl>\")) throw err;\n    }\n    if(!valid_inc(d, \"</value_labels>\")) throw err;\n  }\n\n  if(!valid_inc(d, \"</stata_dta>\")) throw err;\n  const wb = _utils.book_new();\n  _utils.book_append_sheet(wb, ws, \"Sheet1\");\n  wb.bookType = \"dta\" as any;\n  return wb;\n}\n\nfunction parse_legacy(raw: Uint8Array): WorkBook {\n  let vers: number = raw[0];\n  if(SUPPORTED_VERSIONS_LEGACY.indexOf(vers) == -1) throw new Error(\"Not a DTA file\");\n\n  const d: Payload = {\n    ptr: 1,\n    raw,\n    dv: u8_to_dataview(raw)\n  };\n\n  let LE: boolean = true;\n  let nvar: number = 0, nobs: number = 0;\n  let label: string = \"\", timestamp: string = \"\";\n  const var_types: number[] = [];\n  const var_names: string[] = [];\n  const formats: string[] = [];\n\n  /* 5.1 Header */\n  {\n    const byteorder = read_u8(d);\n    switch(byteorder) {\n      case 1: LE = false; break;\n      case 2: LE = true; break;\n      default: throw (`DTA ${vers} Unexpected byteorder ${byteorder}`);\n    }\n\n    let byte = read_u8(d);\n    if(byte != 1) throw (`DTA ${vers} Unexpected filetype ${byte}`);\n    // NOTE: dta_105 technically supports filetype 2\n\n    d.ptr++; // \"unused\"\n    nvar = read_u16(d, LE);\n    nobs = read_u32(d, LE);\n    d.ptr += (vers >= 108 ? 81 : vers >= 103 ? 32 : 30); // TODO: data_label\n    if(vers >= 105) d.ptr += 18; // TODO: time_stamp\n  }\n\n  /* 5.2 Descriptors */\n  const value_label_names: string[] = [];\n  {\n    let C = 0;\n\n    // typlist\n    for(C = 0; C < nvar; ++C) var_types.push(read_u8(d));\n\n    // varlist\n    const w = vers >= 110 ? 33 : 9;\n    for(C = 0; C < nvar; ++C) {\n      var_names.push(u8_to_str(d.raw.slice(d.ptr, d.ptr + w)).replace(/\\x00[\\s\\S]*$/,\"\"));\n      d.ptr += w;\n    }\n\n    // srtlist\n    d.ptr += 2*(nvar + 1);\n\n    // fmtlist\n    const fw = (vers >= 114 ? 49 : vers >= 105 ? 12 : 7);\n    for(C = 0; C < nvar; ++C) {\n      formats.push(u8_to_str(d.raw.slice(d.ptr, d.ptr + fw)).replace(/\\x00[\\s\\S]*$/,\"\"));\n      d.ptr += fw;\n    }\n    // lbllist\n    const lw = vers >= 110 ? 33 : 9;\n    for(let i = 0; i < nvar; ++i, d.ptr += lw) value_label_names[i] = u8_to_latin1(d.raw.slice(d.ptr, d.ptr + lw)).replace(/\\x00.*$/,\"\");\n  }\n\n  /* 5.3 Variable labels */\n  // TODO: should these names be used in the worksheet?\n  d.ptr += (vers >= 106 ? 81 : 32) * nvar;\n\n  /* 5.4 Expansion fields */\n  if(vers >= 105) while(d.ptr < d.raw.length) {\n    const dt = read_u8(d), len = (vers >= 110 ? read_u32 : read_u16)(d, LE);\n    if(dt == 0 && len == 0) break;\n    d.ptr += len;\n  }\n\n  const ws: DenseWorkSheet = (_utils.aoa_to_sheet([var_names], {dense: true} as any) as DenseWorkSheet);\n\n  /* 5.5 Data */\n  for(let R = 0; R < nobs; ++R) {\n    const row: any[] = [];\n    for(let C = 0; C < nvar; ++C) {\n      let t = var_types[C];\n      // TODO: data type processing\n      if((vers == 111 || vers >= 113) && t >= 1 && t <= 244) {\n        /* NOTE: dta_117 restricts strf to ASCII */\n        let s = u8_to_str(d.raw.slice(d.ptr, d.ptr + t));\n        s = s.replace(/\\x00[\\s\\S]*/,\"\");\n        row[C] = s;\n        d.ptr += t;\n      } else if((vers == 112 || vers <= 110) && t >= 0x80) {\n        /* NOTE: dta_105 restricts strf to ASCII */\n        let s = u8_to_str(d.raw.slice(d.ptr, d.ptr + t - 0x7F));\n        s = s.replace(/\\x00[\\s\\S]*/,\"\");\n        row[C] = s;\n        d.ptr += t - 0x7F;\n      } else switch(t) {\n        case 251: case 0x62: row[C] = read_i8(d); break; // byte\n        case 252: case 0x69: row[C] = read_i16(d, LE); break; // int\n        case 253: case 0x6c: row[C] = read_i32(d, LE); break; // long\n        case 254: case 0x66: row[C] = read_f32(d, LE); break; // float\n        case 255: case 0x64: row[C] = read_f64(d, LE); break; // double\n        default: throw (`Unsupported field type ${t} for ${var_names[C]}`);\n      }\n      if(typeof row[C] == \"number\" && formats[C]) row[C] = format_number_dta(row[C], formats[C], t);\n    }\n    _utils.sheet_add_aoa(ws, [row], {origin: -1, sheetStubs: true});\n  }\n\n  /* 5.6 Value labels */\n  // TODO: < 115\n  if(vers >= 115) while(d.ptr < d.raw.length) {\n    const w = 33;\n    let len = read_u32(d, LE);\n    const labname = u8_to_latin1(d.raw.slice(d.ptr, d.ptr + w)).replace(/\\x00.*$/,\"\");\n    d.ptr += w;\n    d.ptr += 3; // padding\n    const labels: string[] = [];\n    {\n      const n = read_u32(d, LE);\n      const txtlen = read_u32(d, LE);\n      const off: number[] = [], val: number[] = [];\n      for(let i = 0; i < n; ++i) off.push(read_u32(d, LE));\n      for(let i = 0; i < n; ++i) val.push(read_u32(d, LE));\n      const str = u8_to_latin1(d.raw.slice(d.ptr, d.ptr + txtlen));\n      d.ptr += txtlen;\n      for(let i = 0; i < n; ++i) labels[val[i]] = str.slice(off[i], str.indexOf(\"\\x00\", off[i]));\n    }\n    const C = value_label_names.indexOf(labname);\n    if(C == -1) throw new Error(`unexpected value label |${labname}|`);\n    for(let R = 1; R < ws[\"!data\"].length; ++R) {\n      const cell = ws[\"!data\"][R][C];\n      cell.t = \"s\"; cell.v = cell.w = labels[(cell.v as number)||0];\n    }\n\n  }\n\n  const wb: WorkBook = _utils.book_new();\n  _utils.book_append_sheet(wb, ws, \"Sheet1\");\n  wb.bookType = \"dta\" as any;\n  return wb;\n}\n\n/** Parse DTA file\n *\n * NOTE: In NodeJS, `Buffer` extends `Uint8Array`\n *\n * @param {Uint8Array} data File data\n */\nfunction parse(data: Uint8Array): WorkBook {\n  if(data[0] >= 102 && data[0] <= 115) return parse_legacy(data);\n  if(data[0] === 60) return parse_tagged(data);\n  throw new Error(\"Not a DTA file\");\n}\n"],
  "mappings": "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",
  "names": []
}
